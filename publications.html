<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Publications - SwiftWare Lab</title>
    <link rel="stylesheet" href="main.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Playfair+Display:wght@700&display=swap" rel="stylesheet">
</head>
<body>
    <header>
        <div class="container site-header">
            <div class="logo">
                <h1><a href="index.html">SwiftWare Lab</a></h1>
            </div>
            <nav>
                <ul>
                    <li><a href="index.html">Home</a></li>
                    <li><a href="research.html">Research</a></li>
                    <li><a href="people.html">People</a></li>
                    <li><a href="publications.html">Publications</a></li> 
                    <li><a href="contact.html">Contact</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <section class="hero">
        <div class="container">
            <h2>Our Publications</h2>
            <p>Explore our research contributions in leading journals and conferences.</p>
        </div>
    </section>

    <div class="container main-content">
        <main class="content-area">
            <section class="publication-list">
                <h2>Recent Publications</h2>
                <div id="publications-list-container">
                    <p>Loading publications...</p>
                </div>
            </section>
        </main>

        <aside class="sidebar">
            <div id="news-feed-placeholder">
                </div>
        </aside>
    </div>

    <footer>
        <div class="container">
            <p>&copy; <span id="current-year-footer"></span> Your Lab Name. All rights reserved.</p>
            <p><a href="#">Privacy Policy</a> | <a href="#">Terms of Use</a></p>
            <p>Powered by HTML & CSS</p>
        </div>
    </footer>

    <script type="text/x-bibtex" id="bibtex-data">
        @inproceedings{mekonnen2024machine,
          author    = {Mahdi Salehi and Kazem Cheshmi}, 
          title     = {Loop Fusion in Matrix Multiplications with Sparse Dependence}, 
          booktitle = {Proceedings of The International Conference on Supercomputing (ICS25)},
          year      = {2025},
          address   = {Salt Lake City, UT}, 
          month     = {June}, 
          url       = {https://www.cheshmi.cc/KazemCheshmi_files/tile_fusion_ics25.pdf},
        }

        @inproceedings{mekonnen2024machine,
          author    = {Delina Mekonnen and Kazem Cheshmi}, 
          title     = {Machine Learning Applications for Early-Stage Ovarian Cancer Diagnosis}, 
          booktitle = {Proceedings of The International Conference for High Performance Computing, Networking, Storage, and Analysis (SC24)},
          year      = {2024},
          address   = {Atlanta, GA}, 
          month     = {November}, 
          note      = {Poster Presentation},
          url       = {https://sc24.supercomputing.org/proceedings/poster/poster_files/post212s2-file3.pdf},
        }

    @inproceedings{10.1145/3581784.3607097,
        author = {Cheshmi, Kazem and Strout, Michelle and Mehri Dehnavi, Maryam},
        title = {Runtime Composition of Iterations for Fusing Loop-carried Sparse Dependence},
        year = {2023},
        isbn = {9798400701092},
        publisher = {Association for Computing Machinery},
        address = {New York, NY, USA},
        url = {https://doi.org/10.1145/3581784.3607097},
        doi = {10.1145/3581784.3607097},
        abstract = {Dependence between iterations in sparse computations causes inefficient use of memory and computation resources. This paper proposes sparse fusion, a technique that generates efficient parallel code for the combination of two sparse matrix kernels, where at least one of the kernels has loop-carried dependencies. Existing implementations optimize individual sparse kernels separately. However, this approach leads to synchronization overheads and load imbalance due to the irregular dependence patterns of sparse kernels, as well as inefficient cache usage due to their irregular memory access patterns. Sparse fusion uses a novel inspection strategy and code transformation to generate parallel fused code optimized for data locality and load balance. Sparse fusion outperforms the best of unfused implementations using ParSy and MKL by an average of 4.2\texttimes{} and is faster than the best of fused implementations using existing scheduling algorithms, such as LBC, DAGP, and wavefront by an average of 4\texttimes{} for various kernel combinations.},
        booktitle = {Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis},
        articleno = {89},
        numpages = {15},
        location = {Denver, CO, USA},
        series = {SC '23}
        }   

    @article{10.1145/3591302,
    author = {Wilkinson, Lucas and Cheshmi, Kazem and Dehnavi, Maryam Mehri},
    title = {Register Tiling for Unstructured Sparsity in Neural Network Inference},
    year = {2023},
    issue_date = {June 2023},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {7},
    number = {PLDI},
    url = {https://doi.org/10.1145/3591302},
    doi = {10.1145/3591302},
    abstract = {Unstructured sparse neural networks are an important class of machine learning (ML) models, as they compact model size and reduce floating point operations. The execution time of these models is frequently dominated by the sparse matrix multiplication (SpMM) kernel, C=A\texttimes{} B, where A is a sparse matrix, and B and C are dense matrices. The unstructured sparsity pattern of matrices in pruned machine learning models along with their sparsity ratio has rendered useless the large class of libraries and systems that optimize sparse matrix multiplications. Reusing registers is particularly difficult because accesses to memory locations should be known statically. This paper proposes Sparse Register Tiling, a new technique composed of an unroll-and-sparse-jam transformation followed by data compression that is specifically tailored to sparsity patterns in ML matrices. Unroll-and-sparse-jam uses sparsity information to jam the code while improving register reuse. Sparse register tiling is evaluated across 2396 weight matrices from transformer and convolutional models with a sparsity range of 60-95\% and provides an average speedup of 1.72\texttimes{} and 2.65\texttimes{} over MKL SpMM and dense matrix multiplication, respectively, on a multicore CPU processor. It also provides an end-to-end speedup of 2.12\texttimes{} for MobileNetV1 with 70\% sparsity on an ARM processor commonly used in edge devices.},
    journal = {Proc. ACM Program. Lang.},
    month = jun,
    articleno = {188},
    numpages = {26},
    keywords = {Sparse Matrix, Pruned Neural Networks, Loop Tiling}
    }
    </script>


    <script>
        // --- BibTeX Parser Utility (part of bibtexParse.js) ---
        // You would typically include this from a separate .js file or CDN.
        // For demonstration, it's included inline.
        const bibtexParse = (bibtexString) => {
            const entries = [];
            const lines = bibtexString.split('\n');
            let currentEntry = null;

            for (const line of lines) {
                const trimmedLine = line.trim();

                if (trimmedLine.startsWith('@')) {
                    if (currentEntry) {
                        entries.push(currentEntry);
                    }
                    const match = trimmedLine.match(/@(\w+)\{([^,]+),/);
                    if (match) {
                        currentEntry = {
                            entryType: match[1].toLowerCase(),
                            entryKey: match[2].trim(),
                            fields: {}
                        };
                    } else {
                        currentEntry = null; // Malformed entry start
                    }
                } else if (currentEntry && trimmedLine.includes('=')) {
                    const parts = trimmedLine.split('=');
                    if (parts.length >= 2) {
                        const key = parts[0].trim().toLowerCase();
                        let value = parts.slice(1).join('=').trim();
                        // Remove braces, quotes, and trailing comma/newline
                        value = value.replace(/[{}"],?$/, '').replace(/^{"/, '').replace(/^{/, '').trim();
                        currentEntry.fields[key] = value;
                    }
                }
            }
            if (currentEntry) {
                entries.push(currentEntry);
            }
            return entries;
        };
        // --- End BibTeX Parser Utility ---


        // Function to format author names (e.g., "Doe, J. and Smith, A.")
        function formatAuthors(authorString) {
            if (!authorString) return '';
            return authorString.split(' and ').map(author => {
                const parts = author.split(',').map(p => p.trim());
                if (parts.length === 2) { // "Last, First"
                    return `${parts[0]}, ${parts[1][0]}.`;
                } else { // "First Last"
                    const nameParts = author.split(' ').map(p => p.trim());
                    if (nameParts.length > 1) {
                        return `${nameParts[nameParts.length - 1]}, ${nameParts[0][0]}.`;
                    }
                    return author; // Fallback
                }
            }).join(', ');
        }


        // Function to render publications
        function renderPublications() {
            const bibtexDataElement = document.getElementById('bibtex-data');
            if (!bibtexDataElement) {
                document.getElementById('publications-list-container').innerHTML = '<p>No BibTeX data found.</p>';
                return;
            }

            const bibtexString = bibtexDataElement.textContent;
            const publications = bibtexParse(bibtexString);
            const container = document.getElementById('publications-list-container');
            container.innerHTML = ''; // Clear "Loading publications..."

            // Sort publications by year, descending
            publications.sort((a, b) => parseInt(b.fields.year) - parseInt(a.fields.year));

            publications.forEach(pub => {
                const fields = pub.fields;
                let title = fields.title || 'Untitled';
                let authors = formatAuthors(fields.author || 'Unknown Author');
                let year = fields.year || '';
                let journalOrBooktitle = '';
                let pages = fields.pages ? `pp. ${fields.pages}` : '';
                let volume = fields.volume ? `Vol. ${fields.volume}` : '';
                let number = fields.number ? `No. ${fields.number}` : '';
                let doi = fields.doi;
                let url = fields.url;
                let publisher = fields.publisher;
                let school = fields.school;
                let address = fields.address;
                let isbn = fields.isbn;

                switch (pub.entryType) {
                    case 'article':
                        journalOrBooktitle = fields.journal || 'Unpublished';
                        break;
                    case 'inproceedings':
                    case 'conference':
                        journalOrBooktitle = fields.booktitle || fields.conference || 'Conference Proceedings';
                        break;
                    case 'book':
                        journalOrBooktitle = publisher || 'Publisher Unknown';
                        break;
                    case 'phdthesis':
                        journalOrBooktitle = `PhD Thesis, ${school || 'University Unknown'}`;
                        if (address) journalOrBooktitle += `, ${address}`;
                        break;
                    // Add more entry types as needed
                    default:
                        journalOrBooktitle = fields.journal || fields.booktitle || fields.publisher || '';
                }


                let infoParts = [];
                if (journalOrBooktitle) infoParts.push(`<strong>${journalOrBooktitle}</strong>`);
                if (volume) infoParts.push(volume);
                if (number) infoParts.push(number);
                if (pages) infoParts.push(pages);
                if (year) infoParts.push(`(${year})`);


                const pubHtml = `
                    <div class="publication-entry">
                        <h3>${title}</h3>
                        <p class="authors">${authors}</p>
                        <p class="journal-info">${infoParts.join(', ')}.</p>
                        ${doi ? `<a href="https://doi.org/${doi}" target="_blank" class="doi-link">DOI</a>` : ''}
                        ${url && !doi ? `<a href="${url}" target="_blank" class="url-link">Full Text</a>` : ''}
                    </div>
                `;
                container.insertAdjacentHTML('beforeend', pubHtml);
            });
        }


        // JavaScript to load news feed content (reused from index.html)
        function loadNewsFeed() {
            fetch('news-feed-snippet.html')
                .then(response => response.text())
                .then(data => {
                    document.getElementById('news-feed-placeholder').innerHTML = data;
                })
                .catch(error => console.error('Error loading news feed:', error));
        }

        // Run functions when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            loadNewsFeed();
            renderPublications();
            // Update the year in the footer
            document.getElementById('current-year-footer').textContent = new Date().getFullYear();
        });
    </script>
</body>
</html>